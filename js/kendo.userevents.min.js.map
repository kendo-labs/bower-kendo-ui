{"version":3,"file":"kendo.userevents.min.js","names":["factory","define","amd","$","undefined$1","kendo","window","support","Class","Observable","now","Date","extend","OS","mobileOS","invalidZeroEvents","android","DEFAULT_MIN_HOLD","DEFAULT_THRESHOLD","browser","msie","PRESS","HOLD","SELECT","START","MOVE","END","CANCEL","TAP","DOUBLETAP","RELEASE","GESTURECHANGE","GESTUREEND","GESTURETAP","THRESHOLD","api","touch","mouse","pointer","ENABLE_GLOBAL_SURFACE","mouseAndTouchPresent","touchDelta","touch1","touch2","x1","x","location","y1","y","x2","y2","dx","dy","center","distance","Math","sqrt","getTouches","e","length","changedTouches","touches","originalEvent","currentTarget","idx","push","id","event","target","type","match","identifier","pointers","msPointers","pointerId","TouchAxis","init","axis","that","this","_updateLocationData","startLocation","velocity","delta","timeStamp","move","offset","timeDelta","initialDelta","client","screen","Touch","userEvents","touchInfo","useClickAsTap","threshold","initialTouch","pressEvent","_clicks","supportDoubleTap","_moved","_finished","press","_holdTimeout","setTimeout","_hold","bind","minHold","_trigger","_tap","_clickTimeout","preventMove","_shouldNotMove","_withinIgnoreThreshold","UserEvents","current","dispose","_start","end","endTime","clearTimeout","activeTouches","splice","inArray","skip","cancel","isMoved","startTime","name","jQueryEvent","data","notify","preventDefault","xDelta","yDelta","withEachUpEvent","callback","downEvents","eventMap","up","split","element","options","filter","ns","guid","_maxTouches","multiTouch","allowSelection","captureUpIfMoved","fastTap","delayedClick","eventNS","handler","fn","call","surface","global","ownerDocument","documentElement","stopPropagation","pressed","on","applyEventMap","version","defaultAction","css","touchAction","preventDragEvent","root","eventCapture","surfaceElement","preventIfMovingProxy","preventIfMoving","eventName","addEventListener","_isMoved","destroy","_destroyed","removeEventListener","kendoDestroy","removeData","_disposeAll","unbind","capture","trigger","_isMultiTouch","_apiCall","_maxTouchesReached","pop","grep","_select","which","_move","_eachTouch","_end","_click","pageX","clientX","pageY","clientY","methodName","matchingTouch","dict","noop","defaultThreshold","value","jQuery"],"sources":["kendo.userevents.js"],"mappings":"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","sourcesContent":["(function (factory) {\n    typeof define === 'function' && define.amd ? define(['kendo.core'], factory) :\n    factory();\n})((function () {\n    var __meta__ = {\n        id: \"userevents\",\n        name: \"User Events\",\n        category: \"framework\",\n        depends: [ \"core\" ],\n        hidden: true\n    };\n\n    (function($, undefined$1) {\n        var kendo = window.kendo,\n            support = kendo.support,\n            Class = kendo.Class,\n            Observable = kendo.Observable,\n            now = Date.now,\n            extend = $.extend,\n            OS = support.mobileOS,\n            invalidZeroEvents = OS && OS.android,\n            DEFAULT_MIN_HOLD = 800,\n            CLICK_DELAY = 300,\n            DEFAULT_THRESHOLD = support.browser.msie ? 5 : 0, // WP8 and W8 are very sensitive and always report move.\n\n            // UserEvents events\n            PRESS = \"press\",\n            HOLD = \"hold\",\n            SELECT = \"select\",\n            START = \"start\",\n            MOVE = \"move\",\n            END = \"end\",\n            CANCEL = \"cancel\",\n            TAP = \"tap\",\n            DOUBLETAP = \"doubleTap\",\n            RELEASE = \"release\",\n            GESTURESTART = \"gesturestart\",\n            GESTURECHANGE = \"gesturechange\",\n            GESTUREEND = \"gestureend\",\n            GESTURETAP = \"gesturetap\";\n\n        var THRESHOLD = {\n            \"api\": 0,\n            \"touch\": 0,\n            \"mouse\": 9,\n            \"pointer\": 9\n        };\n\n        var ENABLE_GLOBAL_SURFACE = (!support.touch || support.mouseAndTouchPresent);\n\n        function touchDelta(touch1, touch2) {\n            var x1 = touch1.x.location,\n                y1 = touch1.y.location,\n                x2 = touch2.x.location,\n                y2 = touch2.y.location,\n                dx = x1 - x2,\n                dy = y1 - y2;\n\n            return {\n                center: {\n                   x: (x1 + x2) / 2,\n                   y: (y1 + y2) / 2\n                },\n\n                distance: Math.sqrt(dx * dx + dy * dy)\n            };\n        }\n\n        function getTouches(e) {\n            var touches = [],\n                originalEvent = e.originalEvent,\n                currentTarget = e.currentTarget,\n                idx = 0, length,\n                changedTouches,\n                touch;\n\n            if (e.api) {\n                touches.push({\n                    id: 2, // hardcoded ID for API call;\n                    event: e,\n                    target: e.target,\n                    currentTarget: e.target,\n                    location: e,\n                    type: \"api\"\n                });\n            }\n            else if (e.type.match(/touch/)) {\n                changedTouches = originalEvent ? originalEvent.changedTouches : [];\n                for (length = changedTouches.length; idx < length; idx ++) {\n                    touch = changedTouches[idx];\n                    touches.push({\n                        location: touch,\n                        event: e,\n                        target: touch.target,\n                        currentTarget: currentTarget,\n                        id: touch.identifier,\n                        type: \"touch\"\n                    });\n                }\n            }\n            else if (support.pointers || support.msPointers) {\n                touches.push({\n                    location: originalEvent,\n                    event: e,\n                    target: e.target,\n                    currentTarget: currentTarget,\n                    id: originalEvent.pointerId,\n                    type: \"pointer\"\n                });\n            } else {\n                touches.push({\n                    id: 1, // hardcoded ID for mouse event;\n                    event: e,\n                    target: e.target,\n                    currentTarget: currentTarget,\n                    location: e,\n                    type: \"mouse\"\n                });\n            }\n\n            return touches;\n        }\n\n        var TouchAxis = Class.extend({\n            init: function(axis, location) {\n                var that = this;\n\n                that.axis = axis;\n\n                that._updateLocationData(location);\n\n                that.startLocation = that.location;\n                that.velocity = that.delta = 0;\n                that.timeStamp = now();\n            },\n\n            move: function(location) {\n                var that = this,\n                    offset = location[\"page\" + that.axis],\n                    timeStamp = now(),\n                    timeDelta = (timeStamp - that.timeStamp) || 1; // Firing manually events in tests can make this 0;\n\n                if (!offset && invalidZeroEvents) {\n                    return;\n                }\n\n                that.delta = offset - that.location;\n\n                that._updateLocationData(location);\n\n                that.initialDelta = offset - that.startLocation;\n                that.velocity = that.delta / timeDelta;\n                that.timeStamp = timeStamp;\n            },\n\n            _updateLocationData: function(location) {\n                var that = this, axis = that.axis;\n\n                that.location = location[\"page\" + axis];\n                that.client = location[\"client\" + axis];\n                that.screen = location[\"screen\" + axis];\n            }\n        });\n\n        var Touch = Class.extend({\n            init: function(userEvents, target, touchInfo) {\n                extend(this, {\n                    x: new TouchAxis(\"X\", touchInfo.location),\n                    y: new TouchAxis(\"Y\", touchInfo.location),\n                    type: touchInfo.type,\n                    useClickAsTap: userEvents.useClickAsTap,\n                    threshold: userEvents.threshold || THRESHOLD[touchInfo.type],\n                    userEvents: userEvents,\n                    target: target,\n                    currentTarget: touchInfo.currentTarget,\n                    initialTouch: touchInfo.target,\n                    id: touchInfo.id,\n                    pressEvent: touchInfo,\n                    _clicks: userEvents._clicks,\n                    supportDoubleTap: userEvents.supportDoubleTap,\n                    _moved: false,\n                    _finished: false\n                });\n            },\n\n            press: function() {\n                this._holdTimeout = setTimeout(this._hold.bind(this), this.userEvents.minHold);\n                this._trigger(PRESS, this.pressEvent);\n            },\n\n            _tap: function(touchInfo) {\n                var that = this;\n                that.userEvents._clicks++;\n                if (that.userEvents._clicks == 1) {\n                    that._clickTimeout = setTimeout(function() {\n                        if (that.userEvents._clicks == 1) {\n                            that._trigger(TAP, touchInfo);\n                        }\n                        else {\n                            that._trigger(DOUBLETAP, touchInfo);\n                        }\n                        that.userEvents._clicks = 0;\n                    }, CLICK_DELAY);\n                }\n            },\n\n            _hold: function() {\n                this._trigger(HOLD, this.pressEvent);\n            },\n\n            move: function(touchInfo) {\n                var that = this;\n                var preventMove = touchInfo.type !== \"api\" && that.userEvents._shouldNotMove;\n\n                if (that._finished || preventMove) { return; }\n\n                that.x.move(touchInfo.location);\n                that.y.move(touchInfo.location);\n\n                if (!that._moved) {\n                    if (that._withinIgnoreThreshold()) {\n                        return;\n                    }\n\n                    if (!UserEvents.current || UserEvents.current === that.userEvents) {\n                        that._start(touchInfo);\n                    } else {\n                        return that.dispose();\n                    }\n                }\n\n                // Event handlers may cancel the drag in the START event handler, hence the double check for pressed.\n                if (!that._finished) {\n                    that._trigger(MOVE, touchInfo);\n                }\n            },\n\n            end: function(touchInfo) {\n                this.endTime = now();\n\n                if (this._finished) { return; }\n\n                // Mark the object as finished if there are blocking operations in the event handlers (alert/confirm)\n                this._finished = true;\n\n                this._trigger(RELEASE, touchInfo); // Release should be fired before TAP (as click is after mouseup/touchend)\n\n                if (this._moved) {\n                    this._trigger(END, touchInfo);\n                } else {\n                    if (!this.useClickAsTap) {\n                        if (this.supportDoubleTap) {\n                            this._tap(touchInfo);\n                        }\n                        else {\n                            this._trigger(TAP, touchInfo);\n                        }\n                    }\n                }\n\n                clearTimeout(this._holdTimeout);\n\n                this.dispose();\n            },\n\n            dispose: function() {\n                var userEvents = this.userEvents,\n                    activeTouches = userEvents.touches;\n\n                this._finished = true;\n                this.pressEvent = null;\n                clearTimeout(this._holdTimeout);\n\n                activeTouches.splice($.inArray(this, activeTouches), 1);\n            },\n\n            skip: function() {\n                this.dispose();\n            },\n\n            cancel: function() {\n                this.dispose();\n            },\n\n            isMoved: function() {\n                return this._moved;\n            },\n\n            _start: function(touchInfo) {\n                clearTimeout(this._holdTimeout);\n\n                this.startTime = now();\n                this._moved = true;\n                this._trigger(START, touchInfo);\n            },\n\n            _trigger: function(name, touchInfo) {\n                var that = this,\n                    jQueryEvent = touchInfo.event,\n                    data = {\n                        touch: that,\n                        x: that.x,\n                        y: that.y,\n                        target: that.target,\n                        event: jQueryEvent\n                    };\n\n                if (that.userEvents.notify(name, data)) {\n                    jQueryEvent.preventDefault();\n                }\n            },\n\n            _withinIgnoreThreshold: function() {\n                var xDelta = this.x.initialDelta,\n                    yDelta = this.y.initialDelta;\n\n                return Math.sqrt(xDelta * xDelta + yDelta * yDelta) <= this.threshold;\n            }\n        });\n\n        function withEachUpEvent(callback) {\n            var downEvents = kendo.eventMap.up.split(\" \"),\n                idx = 0,\n                length = downEvents.length;\n\n            for (; idx < length; idx ++) {\n                callback(downEvents[idx]);\n            }\n        }\n\n        var UserEvents = Observable.extend({\n            init: function(element, options) {\n                var that = this,\n                    filter,\n                    ns = kendo.guid();\n\n                options = options || {};\n                filter = that.filter = options.filter;\n                that.threshold = options.threshold || DEFAULT_THRESHOLD;\n                that.minHold = options.minHold || DEFAULT_MIN_HOLD;\n                that.touches = [];\n                that._maxTouches = options.multiTouch ? 2 : 1;\n                that.allowSelection = options.allowSelection;\n                that.captureUpIfMoved = options.captureUpIfMoved;\n                that.useClickAsTap = !options.fastTap && !support.delayedClick();\n                that.eventNS = ns;\n                that._clicks = 0;\n                that.supportDoubleTap = options.supportDoubleTap;\n\n                element = $(element).handler(that);\n                Observable.fn.init.call(that);\n\n                extend(that, {\n                    element: element,\n                    // the touch events lock to the element anyway, so no need for the global setting\n                    surface: options.global && ENABLE_GLOBAL_SURFACE ? $(element[0].ownerDocument.documentElement) : $(options.surface || element),\n                    stopPropagation: options.stopPropagation,\n                    pressed: false\n                });\n\n                that.surface.handler(that)\n                    .on(kendo.applyEventMap(\"move\", ns), \"_move\")\n                    .on(kendo.applyEventMap(\"up cancel\", ns), \"_end\");\n\n                element.on(kendo.applyEventMap(\"down\", ns), filter, \"_start\");\n\n                if (that.useClickAsTap) {\n                    element.on(kendo.applyEventMap(\"click\", ns), filter, \"_click\");\n                }\n\n                if (support.pointers || support.msPointers) {\n                    //touch-action:none will not work for IE10\n                    if (support.browser.version < 11) {\n                        var defaultAction = \"pinch-zoom double-tap-zoom\";\n                        element.css(\"-ms-touch-action\", options.touchAction && options.touchAction != \"none\" ? defaultAction + \" \" + options.touchAction : defaultAction);\n                    } else {\n                        element.css(\"touch-action\", options.touchAction || \"none\");\n                    }\n                }\n\n                if (options.preventDragEvent) {\n                    element.on(kendo.applyEventMap(\"dragstart\", ns), kendo.preventDefault);\n                }\n\n                element.on(kendo.applyEventMap(\"mousedown\", ns), filter, { root: element }, \"_select\");\n\n                if (that.captureUpIfMoved && support.eventCapture) {\n                    var surfaceElement = that.surface[0],\n                        preventIfMovingProxy = that.preventIfMoving.bind(that);\n\n                    withEachUpEvent(function(eventName) {\n                        surfaceElement.addEventListener(eventName, preventIfMovingProxy, true);\n                    });\n                }\n\n                that.bind([\n                PRESS,\n                HOLD,\n                TAP,\n                DOUBLETAP,\n                START,\n                MOVE,\n                END,\n                RELEASE,\n                CANCEL,\n                GESTURESTART,\n                GESTURECHANGE,\n                GESTUREEND,\n                GESTURETAP,\n                SELECT\n                ], options);\n            },\n\n            preventIfMoving: function(e) {\n                if (this._isMoved()) {\n                    e.preventDefault();\n                }\n            },\n\n            destroy: function() {\n                var that = this;\n\n                if (that._destroyed) {\n                    return;\n                }\n\n                that._destroyed = true;\n\n                if (that.captureUpIfMoved && support.eventCapture) {\n                    var surfaceElement = that.surface[0];\n                    withEachUpEvent(function(eventName) {\n                        surfaceElement.removeEventListener(eventName, that.preventIfMoving);\n                    });\n                }\n\n                that.element.kendoDestroy(that.eventNS);\n                that.surface.kendoDestroy(that.eventNS);\n                that.element.removeData(\"handler\");\n                that.surface.removeData(\"handler\");\n                that._disposeAll();\n\n                that.unbind();\n                delete that.surface;\n                delete that.element;\n                delete that.currentTarget;\n            },\n\n            capture: function() {\n                UserEvents.current = this;\n            },\n\n            cancel: function() {\n                this._disposeAll();\n                this.trigger(CANCEL);\n            },\n\n            notify: function(eventName, data) {\n                var that = this,\n                    touches = that.touches;\n\n                if (this._isMultiTouch()) {\n                    switch (eventName) {\n                        case MOVE:\n                            eventName = GESTURECHANGE;\n                            break;\n                        case END:\n                            eventName = GESTUREEND;\n                            break;\n                        case TAP:\n                            eventName = GESTURETAP;\n                            break;\n                    }\n\n                    extend(data, { touches: touches }, touchDelta(touches[0], touches[1]));\n                }\n\n                return this.trigger(eventName, extend(data, { type: eventName }));\n            },\n\n            // API\n            press: function(x, y, target) {\n                this._apiCall(\"_start\", x, y, target);\n            },\n\n            move: function(x, y) {\n                this._apiCall(\"_move\", x, y);\n            },\n\n            end: function(x, y) {\n                this._apiCall(\"_end\", x, y);\n            },\n\n            _isMultiTouch: function() {\n                return this.touches.length > 1;\n            },\n\n            _maxTouchesReached: function() {\n                return this.touches.length >= this._maxTouches;\n            },\n\n            _disposeAll: function() {\n                var touches = this.touches;\n                while (touches.length > 0) {\n                    touches.pop().dispose();\n                }\n            },\n\n            _isMoved: function() {\n                return $.grep(this.touches, function(touch) {\n                    return touch.isMoved();\n                }).length;\n            },\n\n            _select: function(e) {\n               if (!this.allowSelection || this.trigger(SELECT, { event: e })) {\n                   e.preventDefault();\n               }\n            },\n\n            _start: function(e) {\n                var that = this,\n                    idx = 0,\n                    filter = that.filter,\n                    target,\n                    touches = getTouches(e),\n                    length = touches.length,\n                    touch,\n                    which = e.which;\n\n                if ((which && which > 1) || (that._maxTouchesReached())) {\n                    return;\n                }\n\n                UserEvents.current = null;\n\n                that.currentTarget = e.currentTarget;\n\n                if (that.stopPropagation) {\n                    e.stopPropagation();\n                }\n\n                for (; idx < length; idx ++) {\n                    if (that._maxTouchesReached()) {\n                        break;\n                    }\n\n                    touch = touches[idx];\n\n                    if (filter) {\n                        target = $(touch.currentTarget); // target.is(filter) ? target : target.closest(filter, that.element);\n                    } else {\n                        target = that.element;\n                    }\n\n                    if (!target.length) {\n                        continue;\n                    }\n\n                    touch = new Touch(that, target, touch);\n                    that.touches.push(touch);\n                    touch.press();\n\n                    if (that._isMultiTouch()) {\n                        that.notify(\"gesturestart\", {});\n                    }\n                }\n            },\n\n            _move: function(e) {\n                this._eachTouch(\"move\", e);\n            },\n\n            _end: function(e) {\n                this._eachTouch(\"end\", e);\n            },\n\n            _click: function(e) {\n                var data = {\n                    touch: {\n                        initialTouch: e.target,\n                        target: $(e.currentTarget),\n                        endTime: now(),\n                        x: {\n                            location: e.pageX,\n                            client: e.clientX\n                        },\n                        y: {\n                            location: e.pageY,\n                            client: e.clientY\n                        }\n                    },\n                    x: e.pageX,\n                    y: e.pageY,\n                    target: $(e.currentTarget),\n                    event: e,\n                    type: \"tap\"\n                };\n\n                if (this.trigger(\"tap\", data)) {\n                    e.preventDefault();\n                }\n            },\n\n            _eachTouch: function(methodName, e) {\n                var that = this,\n                    dict = {},\n                    touches = getTouches(e),\n                    activeTouches = that.touches,\n                    idx,\n                    touch,\n                    touchInfo,\n                    matchingTouch;\n\n                for (idx = 0; idx < activeTouches.length; idx ++) {\n                    touch = activeTouches[idx];\n                    dict[touch.id] = touch;\n                }\n\n                for (idx = 0; idx < touches.length; idx ++) {\n                    touchInfo = touches[idx];\n                    matchingTouch = dict[touchInfo.id];\n\n                    if (matchingTouch) {\n                        matchingTouch[methodName](touchInfo);\n                    }\n                }\n            },\n\n            _apiCall: function(type, x, y, target) {\n                this[type]({\n                    api: true,\n                    pageX: x,\n                    pageY: y,\n                    clientX: x,\n                    clientY: y,\n                    target: $(target || this.element)[0],\n                    stopPropagation: $.noop,\n                    preventDefault: $.noop\n                });\n            }\n        });\n\n        UserEvents.defaultThreshold = function(value) {\n            DEFAULT_THRESHOLD = value;\n        };\n\n        UserEvents.minHold = function(value) {\n            DEFAULT_MIN_HOLD = value;\n        };\n\n        kendo.getTouches = getTouches;\n        kendo.touchDelta = touchDelta;\n        kendo.UserEvents = UserEvents;\n     })(window.kendo.jQuery);\n\n}));\n"]}